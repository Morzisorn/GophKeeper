// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItem = `-- name: AddItem :one
INSERT INTO items (user_login, name, type, encrypted_data_content, encrypted_data_nonce, meta)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type AddItemParams struct {
	UserLogin            string   `json:"user_login"`
	Name                 string   `json:"name"`
	Type                 ItemType `json:"type"`
	EncryptedDataContent string   `json:"encrypted_data_content"`
	EncryptedDataNonce   string   `json:"encrypted_data_nonce"`
	Meta                 []byte   `json:"meta"`
}

func (q *Queries) AddItem(ctx context.Context, arg AddItemParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addItem,
		arg.UserLogin,
		arg.Name,
		arg.Type,
		arg.EncryptedDataContent,
		arg.EncryptedDataNonce,
		arg.Meta,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM items
WHERE user_login = $1 AND id = $2
`

type DeleteItemParams struct {
	UserLogin string      `json:"user_login"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) error {
	_, err := q.db.Exec(ctx, deleteItem, arg.UserLogin, arg.ID)
	return err
}

const editItem = `-- name: EditItem :exec
UPDATE items
SET name = $2, encrypted_data_content = $3, encrypted_data_nonce = $4, meta = $5, updated_at =  NOW()
WHERE id = $1
`

type EditItemParams struct {
	ID                   pgtype.UUID `json:"id"`
	Name                 string      `json:"name"`
	EncryptedDataContent string      `json:"encrypted_data_content"`
	EncryptedDataNonce   string      `json:"encrypted_data_nonce"`
	Meta                 []byte      `json:"meta"`
}

func (q *Queries) EditItem(ctx context.Context, arg EditItemParams) error {
	_, err := q.db.Exec(ctx, editItem,
		arg.ID,
		arg.Name,
		arg.EncryptedDataContent,
		arg.EncryptedDataNonce,
		arg.Meta,
	)
	return err
}

const getAllUserItems = `-- name: GetAllUserItems :many
SELECT 
    i.id,
    i.name,
    i.type,
    i.encrypted_data_content,
    i.encrypted_data_nonce,
    i.meta,
    i.created_at,
    i.updated_at
FROM items i
WHERE i.user_login = $1
ORDER BY i.created_at DESC
`

type GetAllUserItemsRow struct {
	ID                   pgtype.UUID      `json:"id"`
	Name                 string           `json:"name"`
	Type                 ItemType         `json:"type"`
	EncryptedDataContent string           `json:"encrypted_data_content"`
	EncryptedDataNonce   string           `json:"encrypted_data_nonce"`
	Meta                 []byte           `json:"meta"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetAllUserItems(ctx context.Context, userLogin string) ([]GetAllUserItemsRow, error) {
	rows, err := q.db.Query(ctx, getAllUserItems, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserItemsRow
	for rows.Next() {
		var i GetAllUserItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.EncryptedDataContent,
			&i.EncryptedDataNonce,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesCounts = `-- name: GetTypesCounts :many
SELECT 
    type, 
    COUNT(*) as count
FROM items
WHERE user_login = $1
GROUP BY type
`

type GetTypesCountsRow struct {
	Type  ItemType `json:"type"`
	Count int64    `json:"count"`
}

func (q *Queries) GetTypesCounts(ctx context.Context, userLogin string) ([]GetTypesCountsRow, error) {
	rows, err := q.db.Query(ctx, getTypesCounts, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesCountsRow
	for rows.Next() {
		var i GetTypesCountsRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT login, password, salt
FROM users
WHERE login = $1
`

func (q *Queries) GetUser(ctx context.Context, login string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, login)
	var i User
	err := row.Scan(&i.Login, &i.Password, &i.Salt)
	return i, err
}

const getUserItemsWithType = `-- name: GetUserItemsWithType :many
SELECT 
    i.id,
    i.name,
    i.type,
    i.encrypted_data_content,
    i.encrypted_data_nonce,
    i.meta,
    i.created_at,
    i.updated_at
FROM items i
WHERE i.user_login = $1 AND i.type = $2
ORDER BY created_at DESC
`

type GetUserItemsWithTypeParams struct {
	UserLogin string   `json:"user_login"`
	Type      ItemType `json:"type"`
}

type GetUserItemsWithTypeRow struct {
	ID                   pgtype.UUID      `json:"id"`
	Name                 string           `json:"name"`
	Type                 ItemType         `json:"type"`
	EncryptedDataContent string           `json:"encrypted_data_content"`
	EncryptedDataNonce   string           `json:"encrypted_data_nonce"`
	Meta                 []byte           `json:"meta"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserItemsWithType(ctx context.Context, arg GetUserItemsWithTypeParams) ([]GetUserItemsWithTypeRow, error) {
	rows, err := q.db.Query(ctx, getUserItemsWithType, arg.UserLogin, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserItemsWithTypeRow
	for rows.Next() {
		var i GetUserItemsWithTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.EncryptedDataContent,
			&i.EncryptedDataNonce,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signUpUser = `-- name: SignUpUser :exec
INSERT INTO users (login, password, salt)
VALUES ($1, $2, $3)
`

type SignUpUserParams struct {
	Login    string `json:"login"`
	Password []byte `json:"password"`
	Salt     string `json:"salt"`
}

func (q *Queries) SignUpUser(ctx context.Context, arg SignUpUserParams) error {
	_, err := q.db.Exec(ctx, signUpUser, arg.Login, arg.Password, arg.Salt)
	return err
}
